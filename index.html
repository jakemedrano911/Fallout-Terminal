<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>ROBCO INDUSTRIES (TM) TERMLINK PROTOCOL</title>
<style>
  @font-face{
    font-family:"FSEX300";
    src:url("fonts/FSEX300.ttf") format("truetype");
    font-weight:normal;
    font-style:normal;
  }
  :root{
    --scale:1;
  }
  html{
    overflow:auto;
  }
  body{
    margin:0;
    overflow:auto;
    background:#000;
    color:#7aff7a;
    font-family:"FSEX300","IBM Plex Mono",ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Courier New",monospace;
    font-size:calc(24px * var(--scale) * 0.9);
    letter-spacing:calc(.75px * var(--scale) * 0.9);
    line-height:1.2;
    display:flex;
    justify-content:center;
    align-items:flex-start;
    min-height:100vh;
    box-sizing:border-box;
    padding:calc(env(safe-area-inset-top) + 8px) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
  }
  #terminal-wrapper{
    position:relative;
    width:calc(828px * var(--scale));
    height:calc(594px * var(--scale) * 0.93);
  }
  #power-screen{
    position:absolute;
    top:0;left:0;right:0;bottom:0;
    background:#000;
    display:flex;
    justify-content:center;
    align-items:center;
    color:#7aff7a;
  }
  #terminal{
    position:relative;
    width:100%;
    height:100%;
    border:calc(4px * var(--scale)) solid #008800;
    box-sizing:border-box;
    padding:calc(6px * var(--scale));
    padding-left:calc(6px * var(--scale) + 4ch);
    overflow:hidden;
    display:none;
    flex-direction:column;
    background:#041204;
    background-image:repeating-linear-gradient(
      rgba(0,0,0,0.55) 0px,
      rgba(0,0,0,0.55) 1px,
      transparent 1px,
      transparent 4px
    );
    border-radius:calc(12px * var(--scale));
  }
  #terminal.powered{
    display:flex;
  }
  #controls-container{
    position:absolute;
    left:calc(100% + (20px * var(--scale)));
    bottom:0;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:flex-end;
  }
  #power-container, #audio-menu, #config-container{
    position:relative;
    display:flex;
    flex-direction:column;
    align-items:center;
  }
  #controls-container span{color:#7aff7a;}
  #audio-menu span{
    margin-top:calc(5px * var(--scale));
  }
  #config-container span{
    margin-top:calc(5px * var(--scale));
  }
  #power-container span{
    position:absolute;
    top:calc(100% + (5px * var(--scale)));
    left:50%;
    transform:translateX(-50%);
  }
  #power-button, #audio-toggle, #config-button{
    background:#b3410e;
    color:#fff;
    border:calc(2px * var(--scale)) solid #008800;
    width:max(44px, calc(40px * var(--scale)));
    height:max(44px, calc(40px * var(--scale)));
    border-radius:0;
    font-size:calc(20px * var(--scale) * 0.9);
    cursor:pointer;
  }
  #config-button{
    background:#b8b20d;
  }
  #config-file{display:none;}
  #audio-menu{
    display:none;
    margin-bottom:calc(10px * var(--scale));
  }
  #volume-controls{
    display:none;
    flex-direction:column;
    position:absolute;
    bottom:calc(100% + (5px * var(--scale)));
    left:50%;
    transform:translateX(-50%);
    background:#041204;
    border:calc(2px * var(--scale)) solid #008800;
    color:#7aff7a;
    padding:calc(5px * var(--scale));
    z-index:1;
  }
  #volume-controls label{
    display:flex;
    align-items:center;
    font-size:calc(12px * var(--scale) * 0.9);
    margin-bottom:calc(5px * var(--scale));
  }
  #volume-controls label:last-child{
    margin-bottom:0;
  }
  #volume-controls input[type=range]{
    margin-left:calc(5px * var(--scale));
  }
  #terminal::before,
  #terminal::after{
    content:"";
    position:absolute;
    left:0;right:0;
    top:0;
    height:20%;
    pointer-events:none;
    background:linear-gradient(
      to bottom,
      rgba(0,0,0,0) 0%,
      rgba(0,0,0,0.3) 50%,
      rgba(0,0,0,0) 100%
    );
    mix-blend-mode:multiply;
    border-radius:inherit;
    animation:crt-band 5.6s linear infinite;
    z-index:2;
  }
  #terminal::after{
    opacity:0.5;
    animation-delay:-2.8s;
  }
  @keyframes crt-band{
    from{transform:translateY(-100%);}
    to{transform:translateY(600%);}
  }
  @media (prefers-reduced-motion: reduce){
    #terminal::after{content:none;}
    #terminal::before{
      animation:none;
      top:0;
      height:100%;
      transform:none;
      opacity:0.15;
      background:rgba(0,0,0,0.2);
    }
  }
  #header, #content{
    white-space:pre-wrap;
  }
  #content{
    flex:1;
    overflow:hidden;
    word-break:break-word;
    max-height:100%;
  }
  #input{
    white-space:pre;
    min-height:1.2em;
    outline:none;
    background:transparent;
    border:none;
    color:inherit;
    font:inherit;
    letter-spacing:inherit;
    line-height:inherit;
    caret-color:transparent;
    flex-shrink:0;
    align-self:flex-start;
    overflow:hidden;
  }
  #input::before{
    content:"> ";
  }
  #input::after{
    content:"\2588";
    animation:blink 1s steps(1,end) infinite;
  }
  .response{
    opacity:1;
    transition:opacity 1s;
  }
  .response.fade{
    opacity:0;
  }
  @keyframes blink{50%{opacity:0;}}
  .option{
    display:flex;
    align-items:center;
    width:100%;
    cursor:pointer;
    padding:0 calc(4px * var(--scale));
    line-height:1;
  }
  .option + .option{
    margin-top:calc(4px * var(--scale));
  }
  .option:hover, .option:focus, .option.selected{
    background:#008800;
    color:#041204;
  }
  #hack-wrap{display:flex;justify-content:flex-start;align-items:flex-start;width:100%;gap:2ch;}
  #hacking{white-space:pre;font:inherit;flex-shrink:0;}
  #hacking .word{cursor:pointer;}
  #hacking .char:hover,
  #hacking .char.highlight{background:#008800;color:#041204;}
  #hacking .word:hover,
  #hacking .word.highlight{background:#008800;color:#041204;}
  #hacking .bracket{cursor:pointer;}
  #hacking .bracket:hover,
  #hacking .bracket.highlight{background:#008800;color:#041204;}
  #hack-messages{white-space:pre;display:flex;flex-direction:column;justify-content:flex-end;align-items:flex-start;height:100%;flex:1;line-height:1;align-self:flex-start;padding:0 calc(8px * var(--scale)) calc(24px * var(--scale)) 0;overflow:hidden;}
  #hack-messages #input{margin-top:0;align-self:flex-start;}
  #hack-prompt{margin-top:calc(4px * var(--scale));}
  .hack-message{text-align:left;}
  .hack-row{line-height:1;}
  .hack-addr{display:inline-block;width:6ch;}
  .hack-block{display:inline-block;width:12ch;}
  .hack-gap{display:inline-block;width:4ch;}
  #hacking, .hack-row { letter-spacing: inherit; }
  #content.hack-content{display:flex;flex-direction:column;justify-content:flex-start;padding:calc(4px * var(--scale));padding-bottom:calc(22px * var(--scale));}
  #header.hack-header{padding-top:calc(16px * var(--scale));padding-bottom:calc(4px * var(--scale));}
  #header.hack-header #hack-title{margin-top:calc(4px * var(--scale));margin-bottom:calc(8px * var(--scale));}
  #header.hack-header #attempts{margin-bottom:calc(4px * var(--scale));}
    #header.hack-header #hack-warning{margin-bottom:calc(4px * var(--scale));}
    #terminal-screen{height:100%;display:flex;flex-direction:column;transition:transform 1s linear;}
    #terminal.locking #terminal-screen{transform:translateY(-100%);}
    #terminal.locked #content{opacity:0.2;}
  #lockout{position:absolute;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;text-align:center;white-space:pre-wrap;}
</style>
</head>
<body>
<div id="terminal-wrapper">
  <div id="power-screen">POWER OFF - PRESS POWER BUTTON</div>
  <div id="terminal">
    <div id="terminal-screen">
      <div id="header"></div>
      <div id="content"></div>
      <div id="input" contenteditable="true"></div>
    </div>
  </div>
  <div id="controls-container">
    <div id="audio-menu">
      <button id="audio-toggle" aria-label="Audio">&#x1F50A;</button>
      <span>Audio</span>
      <div id="volume-controls">
        <label>Hum <input type="range" min="0" max="10" value="1" id="hum-volume"></label>
        <label>Scroll <input type="range" min="0" max="10" value="2" id="scroll-volume"></label>
        <label>Focus <input type="range" min="0" max="10" value="2" id="focus-volume"></label>
        <label>Select <input type="range" min="0" max="10" value="5" id="select-volume"></label>
      </div>
    </div>
    <div id="config-container">
      <input type="file" id="config-file" accept="application/json" style="display:none">
      <button id="config-button" aria-label="Holotape">&#x1F4FC;</button>
      <span>Holotape</span>
    </div>
    <div id="power-container">
      <button id="power-button" aria-label="Power">&#x23FB;</button>
      <span>Power</span>
    </div>
  </div>
</div>
<script>
function updateScale(){
  const scale=Math.min(
    3,
    Math.max(
      0.7,
        Math.min(
          window.innerWidth*0.98/621,
          window.innerHeight*0.98/660
        )*0.93
    )
  );
  document.documentElement.style.setProperty('--scale',scale);
}
window.addEventListener('resize',updateScale);
updateScale();
let titleLines=[];
let headerLines=[];
let screens={};
let hacking={};
let startLocked=true;

let uploadedConfig=null;

async function loadConfig(){
  let cfg;
  if(uploadedConfig){
    cfg=uploadedConfig;
  }else{
    cfg=await fetch('config.json').then(res=>res.json());
  }
  titleLines=cfg.titleLines;
  headerLines=cfg.headerLines;
  screens=cfg.screens;
  hacking=cfg.hacking;
  startLocked=cfg.locked!==undefined?cfg.locked:true;
}

const terminal=document.getElementById('terminal');
const terminalScreen=document.getElementById('terminal-screen');
const powerButton=document.getElementById('power-button');
const powerScreen=document.getElementById('power-screen');
const header=document.getElementById('header');
const content=document.getElementById('content');
const input=document.getElementById('input');
const configFile=document.getElementById('config-file');
const configButton=document.getElementById('config-button');
const historyEl=content;

configFile.addEventListener('change',async e=>{
  const file=e.target.files[0];
  if(file){
    try{
      const text=await file.text();
      uploadedConfig=JSON.parse(text);
    }catch(err){
      console.error('Invalid configuration file',err);
      uploadedConfig=null;
    }
  }
});
configButton.addEventListener('click',()=>configFile.click());
let currentOptions=[];
let selected=-1;
let typing=false;
let baseDelay=10;
let speed=1;
let inputText="";
let screenHistory=[];
let skipNextClick=false;
let powered=false;
const MAX_INPUT_CHARS=64;
let hackingActive=false;
let hackingData=null;
let terminalLocked=false;

function restoreInput(){
  if(input.parentElement!==terminalScreen){
    terminalScreen.appendChild(input);
  }
}

const audioMenu=document.getElementById('audio-menu');
const audioToggle=document.getElementById('audio-toggle');
const volumeControls=document.getElementById('volume-controls');
const humSlider=document.getElementById('hum-volume');
const scrollSlider=document.getElementById('scroll-volume');
const focusSlider=document.getElementById('focus-volume');
const selectSlider=document.getElementById('select-volume');

audioToggle.addEventListener('click',()=>{
  volumeControls.style.display=volumeControls.style.display==='flex'?'none':'flex';
});

let humVolume=humSlider.value/10;
let scrollVolume=scrollSlider.value/10;
let focusVolume=focusSlider.value/10;
let selectVolume=selectSlider.value/10;
let fanHumBuffer,fanHumSource,fanHumGain;

humSlider.addEventListener('input',()=>{
  humVolume=humSlider.value/10;
  if(fanHumGain) fanHumGain.gain.value=humVolume;
});
scrollSlider.addEventListener('input',()=>{scrollVolume=scrollSlider.value/10;});
focusSlider.addEventListener('input',()=>{focusVolume=focusSlider.value/10;});
selectSlider.addEventListener('input',()=>{selectVolume=selectSlider.value/10;});

input.addEventListener('input',updateInput);
input.addEventListener('keydown',e=>{
  if(e.key==='Enter'){
    e.preventDefault();
    handleCommand(inputText);
  }
});

function updateInput(){
  let text=input.textContent.replace(/\n/g,'');
  const limit=hackingActive?20:MAX_INPUT_CHARS;
  if(text.length>limit){
    text=text.slice(0,limit);
  }
  input.textContent=text;
  inputText=text;
  placeCaretAtEnd(input);
}
updateInput();

function placeCaretAtEnd(el){
  const range=document.createRange();
  range.selectNodeContents(el);
  range.collapse(false);
  const sel=window.getSelection();
  sel.removeAllRanges();
  sel.addRange(range);
}

function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]]=[arr[j],arr[i]];
  }
}

function escapeHtml(str){
  return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

async function startHacking(){
  terminalLocked=false;
  hackingActive=true;
  try{
    const res=await fetch('Hacking Words.txt');
    const text=await res.text();
    const all=(text.match(/[A-Za-z]+/g)||[]).map(w=>w.toUpperCase());
    const byLen={};
    for(const w of all){
      const l=w.length;
      (byLen[l]||(byLen[l]=new Set())).add(w);
    }
    const difficulties=hacking.difficulties;
    if(!Array.isArray(difficulties)||!difficulties.length) throw new Error('Invalid hacking configuration');
    let diff;
    if(hacking.difficulty){
      diff=difficulties.find(d=>d.name===hacking.difficulty);
      if(!diff) throw new Error('Invalid hacking configuration');
    }else{
      diff=difficulties[Math.floor(Math.random()*difficulties.length)];
    }
    let pool=[];
    for(let l=diff.length[0]; l<=diff.length[1]; l++){
      if(byLen[l]) pool=pool.concat(Array.from(byLen[l]));
    }
    const fixedPassword=hacking.password?hacking.password.toUpperCase():null;
    const fixedDuds=(hacking.dudWords||[]).map(w=>w.toUpperCase());
    if(fixedPassword){
      if(fixedPassword.length<diff.length[0]||fixedPassword.length>diff.length[1]) throw new Error('Invalid hacking configuration');
      if(!byLen[fixedPassword.length]||!byLen[fixedPassword.length].has(fixedPassword)) throw new Error('Invalid hacking configuration');
    }
    for(const w of fixedDuds){
      if(w===fixedPassword) throw new Error('Invalid hacking configuration');
      if(w.length<diff.length[0]||w.length>diff.length[1]) throw new Error('Invalid hacking configuration');
      if(!byLen[w.length]||!byLen[w.length].has(w)) throw new Error('Invalid hacking configuration');
    }
    const maxCount=diff.wordCount[1];
    const minCount=Math.max(diff.wordCount[0],fixedDuds.length+1);
    if(minCount>maxCount) throw new Error('Invalid hacking configuration');
    let count=minCount+Math.floor(Math.random()*(maxCount-minCount+1));
    pool=pool.filter(w=>w!==fixedPassword && !fixedDuds.includes(w));
    if(pool.length<count-fixedDuds.length-(fixedPassword?1:0)) throw new Error('Insufficient words');
    shuffle(pool);
    let wordList=fixedDuds.concat(pool.slice(0,count-fixedDuds.length-(fixedPassword?1:0)));
    if(fixedPassword) wordList.push(fixedPassword);
    shuffle(wordList);
    const password=fixedPassword||wordList[Math.floor(Math.random()*wordList.length)];
    hackingData={
      attempts:4,
      maxAttempts:4,
      password,
      wordList,
      difficulty:diff.name,
      activeWords:wordList.filter(w=>w!==password)
    };
    await renderHackScreen();
  }catch(err){
    console.error('Failed to start hacking',err);
    hackingActive=false;
    if(err.message==='Invalid hacking configuration'){
      displayMessage('INVALID HACKING CONFIG');
    }else{
      displayMessage('WORD LIST UNAVAILABLE');
    }
  }
}

function detectBrackets(block){
  const pairs=[];
  const wordIndices=new Set();
  for(const w of block.words){
    const seg=w.segment||w.word;
    for(let k=0;k<seg.length;k++){
      wordIndices.add(w.start+k);
    }
  }
  const openToClose={'(':')','{':'}','[':']','<':'>'};
  const closeToOpen={')':'(','}':'{',']':'[','>':'<'};
  const stack=[];
  for(let i=0;i<block.chars.length;i++){
    if(wordIndices.has(i)){
      stack.length=0;
      continue;
    }
    const ch=block.chars[i];
    if(openToClose[ch]){
      stack.push({ch,index:i});
    }else if(closeToOpen[ch]){
      for(let s=stack.length-1;s>=0;s--){
        if(stack[s].ch===closeToOpen[ch]){
          pairs.push({start:stack[s].index,end:i});
          stack.splice(s,1);
          break;
        }
      }
    }
  }
  block.brackets=pairs;
}

function blockHtml(block){
  const parts=[];
  const regions=[];
  for(const w of block.words){
    const seg=w.segment||w.word;
    regions.push({start:w.start,end:w.start+seg.length,type:'word',word:w.word,text:seg});
  }
  for(const b of block.brackets||[]){
    regions.push({start:b.start,end:b.end+1,type:'bracket'});
  }
  regions.sort((a,b)=>a.start-b.start);
  let idx=0;
  const wrapChar=ch=>`<span class="char">${escapeHtml(ch)}</span>`;
  for(const r of regions){
    while(idx<r.start){
      parts.push(wrapChar(block.chars[idx++]));
    }
    if(r.type==='word'){
      parts.push(`<span class="word" data-word="${r.word}">${r.text}</span>`);
    }else if(r.type==='bracket'){
      const seg=block.chars.slice(r.start,r.end).map(wrapChar).join('');
      parts.push(`<span class="bracket">${seg}</span>`);
    }
    idx=r.end;
  }
  while(idx<block.chars.length){
    parts.push(wrapChar(block.chars[idx++]));
  }
  return parts.join('');
}

async function renderHackScreen(){
  speed=1;
  typing=true;
  header.innerHTML='';
  content.innerHTML='';
  header.style.marginLeft='';
  header.style.textAlign='';
  header.classList.add('hack-header');
  content.classList.add('hack-content');
  const title=document.createElement('div');
  title.id='hack-title';
  header.appendChild(title);
  const prompt=document.createElement('div');
  prompt.id='hack-prompt';
  header.appendChild(prompt);
  const attempts=document.createElement('div');
  attempts.id='attempts';
  header.appendChild(attempts);
  const warning=document.createElement('div');
  warning.id='hack-warning';
  header.appendChild(warning);
  const wrap=document.createElement('div');
  wrap.id='hack-wrap';
  content.appendChild(wrap);
  const grid=document.createElement('div');
  grid.id='hacking';
  wrap.appendChild(grid);
  const messages=document.createElement('div');
  messages.id='hack-messages';
  wrap.appendChild(messages);
  startScrollSound();
  hackingData.attemptsEl=attempts;
  hackingData.promptEl=prompt;
  hackingData.warningEl=warning;
  updateAttempts();
  const promptText=prompt.textContent;
  const attemptsText=attempts.textContent;
  title.textContent='';
  prompt.textContent='';
  attempts.textContent='';
  warning.textContent='';
  await typeText(title,'ROBCO INDUSTRIES (TM) TERMLINK PROTOCOL');
  title.textContent=title.textContent.trimEnd();
  await typeText(prompt,promptText);
  prompt.textContent=prompt.textContent.trimEnd();
  await typeText(attempts,attemptsText);
  attempts.textContent=attempts.textContent.trimEnd();
  const rows=17,cols=12,total=rows*2;
    const base=0xF000+Math.floor(Math.random()*(0xFFF-cols*total));
    const chars='{}[]()<>/\\|;:!@#$%^&*-_=+,.?';
    hackingData.junkChars=chars;
    const blocks=[];
  for(let i=0;i<total;i++){
    const arr=[];
    for(let j=0;j<cols;j++) arr.push(chars[Math.floor(Math.random()*chars.length)]);
    blocks.push({addr:(base+i*cols).toString(16).toUpperCase().padStart(4,'0'),chars:arr,words:[]});
  }
  const MAX_PLACEMENT_ATTEMPTS = 1000;
    for(const word of hackingData.wordList){
    const parts=[];
    for(let i=0;i<word.length;i+=cols) parts.push(word.slice(i,i+cols));
    const maxLen=parts.reduce((m,p)=>Math.max(m,p.length),0);
    if(parts.length>rows){
      console.warn('Word too long to place', word);
      continue;
    }
    let placed = false;
    for(let attempts=0; attempts<MAX_PLACEMENT_ATTEMPTS; attempts++){
      const col=Math.floor(Math.random()*2);
      const row=Math.floor(Math.random()*(rows-parts.length+1));
      const start=Math.floor(Math.random()*(cols-maxLen+1));
      let ok=true;
      for(let p=0;p<parts.length;p++){
        const block=blocks[col*rows+row+p];
        const seg=parts[p];
        if(block.words.some(w=>!(start+seg.length<=w.start || start>=w.start+(w.segment||w.word).length))){
          ok=false;break;
        }
      }
      if(!ok) continue;
      for(let p=0;p<parts.length;p++){
        const block=blocks[col*rows+row+p];
        const seg=parts[p];
        for(let k=0;k<seg.length;k++) block.chars[start+k]=seg[k];
        block.words.push({start,word,segment:seg});
      }
      placed = true;
      break;
    }
    if(!placed){
      console.warn('Failed to place word', word);
    }
    }
    for(const block of blocks) detectBrackets(block);
    let gridHtml='';
  for(let r=0;r<rows;r++){
    const left=blocks[r];
    const right=blocks[r+rows];
    gridHtml+=`<div class="hack-row"><span class="hack-addr">0x${left.addr}</span> <span class="hack-block">${blockHtml(left)}</span><span class="hack-gap"></span><span class="hack-addr">0x${right.addr}</span> <span class="hack-block">${blockHtml(right)}</span></div>`;
  }
  await typeHtml(grid, gridHtml);
  stopScrollSound();
  typing=false;
  speed=1;
  grid.querySelectorAll('.char').forEach(span=>{
    span.addEventListener('mouseenter',()=>{
      span.classList.add('highlight');
      playCharFocusSound();
    });
    span.addEventListener('mouseleave',()=>span.classList.remove('highlight'));
  });
  grid.querySelectorAll('.word').forEach(span=>{
    span.addEventListener('mouseenter',()=>{
      grid.querySelectorAll(`.word[data-word="${span.dataset.word}"]`).forEach(w=>w.classList.add('highlight'));
      playWordFocusSound();
    });
    span.addEventListener('mouseleave',()=>{
      grid.querySelectorAll(`.word[data-word="${span.dataset.word}"]`).forEach(w=>w.classList.remove('highlight'));
    });
    span.addEventListener('click',()=>processGuess(span.dataset.word));
  });
  grid.querySelectorAll('.bracket').forEach(span=>{
    span.addEventListener('mouseenter',()=>{
      span.classList.add('highlight');
      playCharFocusSound();
    });
    span.addEventListener('mouseleave',()=>span.classList.remove('highlight'));
    span.addEventListener('click',()=>useBracket(span));
  });
  wrap.style.height=grid.clientHeight+'px';
  messages.appendChild(input);
  hackingData.blocks=blocks;
  hackingData.messages=messages;
  hackingData.grid=grid;
  input.focus();
}

function updateAttempts(){
  const a=hackingData.attempts;
  const word=a===1?'ATTEMPT':'ATTEMPTS';
  const blocks='â–ˆ'.repeat(Math.min(a,4));
  hackingData.attemptsEl.textContent=`${a} ${word} LEFT: ${blocks}`;
  hackingData.promptEl.textContent=a===1?'!!! WARNING: LOCKOUT IMMINENT !!!':'ENTER PASSWORD NOW';
}

function lockTerminal(){
  hackingActive=false;
  terminalLocked=true;
  hackingData.promptEl.textContent='';
  hackingData.warningEl.textContent='';
  hackingData.attemptsEl.textContent='';
  const overlay=document.createElement('div');
  overlay.id='lockout';
  overlay.textContent='TERMINAL LOCKOUT\nPLEASE CONTACT SYSTEM ADMINISTRATOR';
  terminalScreen.addEventListener('transitionend',()=>{
    terminal.classList.add('locked');
    terminal.appendChild(overlay);
  },{once:true});
  terminal.classList.add('locking');
}

function trimHackMessages(){
  const msg=hackingData.messages;
  while(msg.scrollHeight>msg.clientHeight && msg.firstChild && msg.firstChild!==input){
    msg.removeChild(msg.firstChild);
  }
}

function insertHackBox(box){
  const msg=hackingData.messages;
  msg.insertBefore(box,input);
  trimHackMessages();
}

function processGuess(guess){
  if(!hackingActive) return;
  guess=guess.trim().toUpperCase();
  const override=guess==='ADMIN OVERRIDE';
  const allowances=guess==='ADMIN ALLOWANCES';
  const len=hackingData.password.length;
  const box=document.createElement('div');
  box.className='hack-message';
  const guessLine=document.createElement('div');
  guessLine.textContent=`>${override?'ADMIN OVERRIDE':allowances?'ADMIN ALLOWANCES':guess}`;
  box.appendChild(guessLine);
  playEnterCharSound();
  if(allowances){
    hackingData.attempts=99;
    hackingData.maxAttempts=99;
    updateAttempts();
    const ok=document.createElement('div');
    ok.textContent='Allowances set to 99.';
    box.appendChild(ok);
    insertHackBox(box);
  }else if(override || guess===hackingData.password){
    const likeLine=document.createElement('div');
    likeLine.textContent=`${len}/${len} correct`;
    box.appendChild(likeLine);
    const ok=document.createElement('div');
    ok.textContent='Access granted.';
    box.appendChild(ok);
    insertHackBox(box);
    hackingActive=false;
    hackingData.promptEl.textContent='';
    hackingData.warningEl.textContent='';
    hackingData.attemptsEl.textContent='';
    playPasswordResult(true);
    setTimeout(()=>showIntro(),500);
  }else{
    let like=0;
    for(let i=0;i<len;i++) if(guess[i]===hackingData.password[i]) like++;
    const denied=document.createElement('div');
    denied.textContent='Entry denied';
    box.appendChild(denied);
    const likeLine=document.createElement('div');
    likeLine.textContent=`${like}/${len} correct`;
    box.appendChild(likeLine);
    insertHackBox(box);
    hackingData.attempts--;
    updateAttempts();
    playPasswordResult(false);
    if(hackingData.attempts<=0){
      lockTerminal();
    }
  }
  input.textContent='';
  inputText='';
  updateInput();
  input.focus();
}

function addHackMessage(text){
  const box=document.createElement('div');
  box.className='hack-message';
  const line=document.createElement('div');
  line.textContent=text;
  box.appendChild(line);
  insertHackBox(box);
}

function removeDud(){
  const candidates=hackingData.activeWords.filter(w=>!hackingData.removedWords?.has(w));
  if(!candidates.length) return;
  const word=candidates[Math.floor(Math.random()*candidates.length)];
  if(!hackingData.removedWords) hackingData.removedWords=new Set();
  hackingData.removedWords.add(word);
  hackingData.activeWords=hackingData.activeWords.filter(w=>w!==word);
  const chars=hackingData.junkChars;
  hackingData.grid.querySelectorAll(`.word[data-word="${word}"]`).forEach(span=>{
    const len=span.textContent.length;
    let junk='';
    for(let i=0;i<len;i++) junk+=chars[Math.floor(Math.random()*chars.length)];
    span.innerHTML=junk.split('').map(c=>`<span class="char">${escapeHtml(c)}</span>`).join('');
    span.classList.remove('word');
    span.removeAttribute('data-word');
  });
  addHackMessage('> Dud removed');
}

function resetAttempts(){
  hackingData.attempts=hackingData.maxAttempts;
  updateAttempts();
  addHackMessage('> Allowance replenished');
}

function useBracket(span){
  if(span.classList.contains('used')) return;
  span.classList.add('used');
  const len=span.textContent.length;
  const chars=hackingData.junkChars;
  let junk='';
  for(let i=0;i<len;i++) junk+=chars[Math.floor(Math.random()*chars.length)];
  const frag=document.createDocumentFragment();
  for(const ch of junk){
    const el=document.createElement('span');
    el.className='char';
    el.textContent=ch;
    frag.appendChild(el);
  }
  span.replaceWith(frag);
  if(Math.random()<0.5){
    removeDud();
  }else{
    resetAttempts();
  }
}

function displayMessage(text){
  const div=document.createElement('div');
  div.className='response';
  div.textContent=text;
  terminal.insertBefore(div,input);
  setTimeout(()=>div.classList.add('fade'),5000);
  setTimeout(()=>div.remove(),6000);
}

function clearResponses(){
  document.querySelectorAll('.response').forEach(el=>el.remove());
}

function handleCommand(cmd){
  clearResponses();
  if(terminalLocked){
    input.textContent='';
    inputText='';
    updateInput();
    return;
  }
  const command=cmd.trim().toLowerCase();
  if(command==='syntaxhelper'){
    if(hackingActive){
      hackingData.grid.querySelectorAll('.bracket').forEach(span=>span.classList.add('highlight'));
      setTimeout(()=>hackingData.grid.querySelectorAll('.bracket').forEach(span=>span.classList.remove('highlight')),1000);
    }else{
      displayMessage('command not recognized.');
    }
  }else if(hackingActive){
    processGuess(cmd.trim().toUpperCase().slice(0,20));
  }else if(command==='back'){
    goBack();
  }else if(command==='?'||command==='help'){
    showScreen('help');
  }else if(screens[command]){
    showScreen(command);
  }else{
    displayMessage('command not recognized.');
  }
  input.textContent='';
  inputText='';
  updateInput();
  input.focus();
}

const audioCtx=new (window.AudioContext||window.webkitAudioContext)();
fanHumGain=audioCtx.createGain();
fanHumGain.gain.value=humVolume;
fanHumGain.connect(audioCtx.destination);

let scrollBuffer;
let scrollTimeout;
let lastScrollTime=0;
const scrollIntervalMs=750;

async function loadScrollSound(){
  const res=await fetch('Terminal 3/charscroll_lp.wav');
  const buf=await res.arrayBuffer();
  scrollBuffer=await audioCtx.decodeAudioData(buf);
}

function playScrollSound(){
  if(!scrollBuffer) return;
  lastScrollTime=Date.now();
  const src=audioCtx.createBufferSource();
  src.buffer=scrollBuffer;
  const gain=audioCtx.createGain();
  gain.gain.value=scrollVolume;
  src.connect(gain).connect(audioCtx.destination);
  src.start();
  scrollTimeout=setTimeout(playScrollSound,scrollIntervalMs);
}
function startScrollSound(){
  if(scrollTimeout) return;
  const elapsed=Date.now()-lastScrollTime;
  if(elapsed>=scrollIntervalMs){
    playScrollSound();
  }else{
    scrollTimeout=setTimeout(playScrollSound,scrollIntervalMs-elapsed);
  }
}

function goBack(){
  if(screenHistory.length>1){
    screenHistory.pop();
    const prev=screenHistory.pop();
    showScreen(prev);
  }
}
function stopScrollSound(){
  if(!scrollTimeout) return;
  clearTimeout(scrollTimeout);
  scrollTimeout=null;
}

async function startFanHum(){
  if(!fanHumBuffer){
    const res=await fetch('Terminal 3/fanhum_lp.wav');
    const buf=await res.arrayBuffer();
    fanHumBuffer=await audioCtx.decodeAudioData(buf);
  }
  stopFanHum();
  fanHumSource=audioCtx.createBufferSource();
  fanHumSource.buffer=fanHumBuffer;
  fanHumSource.loop=true;
  fanHumSource.connect(fanHumGain);
  fanHumSource.start(0);
}

function stopFanHum(){
  if(fanHumSource){
    fanHumSource.stop();
    fanHumSource.disconnect();
    fanHumSource=null;
  }
}

function playFocusSound(){
  const audio=new Audio('Terminal 3/menu/menu_focus.wav');
  audio.volume=focusVolume;
  audio.play();
}

function playSelectSound(){
  const files=[
    'Terminal 4/HDD/HDD1/HDD101.wav',
    'Terminal 4/HDD/HDD1/HDD102.wav',
    'Terminal 4/HDD/HDD1/HDD103.wav',
    'Terminal 4/HDD/HDD1/HDD104.wav',
    'Terminal 4/HDD/HDD1/HDD105.wav',
    'Terminal 4/HDD/HDD1/HDD106.wav',
    'Terminal 4/HDD/HDD1/HDD107.wav',
    'Terminal 4/HDD/HDD1/HDD108.wav',
    'Terminal 4/HDD/HDD1/HDD109.wav',
    'Terminal 4/HDD/HDD1/HDD110.wav',
    'Terminal 4/HDD/HDD1/HDD111.wav',
    'Terminal 4/HDD/HDD1/HDD112.wav',
    'Terminal 4/HDD/HDD1/HDD113.wav',
    'Terminal 4/HDD/HDD1/HDD114.wav',
    'Terminal 4/HDD/HDD1/HDD115.wav'
  ];
  const enterFiles=[
    'Terminal 3/enter/charenter_01.wav',
    'Terminal 3/enter/charenter_02.wav',
    'Terminal 3/enter/charenter_03.wav'
  ];
  const hddSrc=files[Math.floor(Math.random()*files.length)];
  const enterSrc=enterFiles[Math.floor(Math.random()*enterFiles.length)];
  const hddAudio=new Audio(hddSrc);
  hddAudio.volume=selectVolume;
  hddAudio.play();
  const enterAudio=new Audio(enterSrc);
  enterAudio.volume=selectVolume;
  enterAudio.play();
}

function playCharFocusSound(){
  const files=[
    'Terminal 3/single/charsingle_01.wav',
    'Terminal 3/single/charsingle_02.wav',
    'Terminal 3/single/charsingle_03.wav',
    'Terminal 3/single/charsingle_04.wav',
    'Terminal 3/single/charsingle_05.wav',
    'Terminal 3/single/charsingle_06.wav'
  ];
  const src=files[Math.floor(Math.random()*files.length)];
  const audio=new Audio(src);
  audio.volume=focusVolume;
  audio.play();
}

function playWordFocusSound(){
  const files=[
    'Terminal 3/multiple/charmultiple_01.wav',
    'Terminal 3/multiple/charmultiple_02.wav',
    'Terminal 3/multiple/charmultiple_03.wav',
    'Terminal 3/multiple/charmultiple_04.wav'
  ];
  const src=files[Math.floor(Math.random()*files.length)];
  const audio=new Audio(src);
  audio.volume=focusVolume;
  audio.play();
}

function playEnterCharSound(){
  const files=[
    'Terminal 3/enter/charenter_01.wav',
    'Terminal 3/enter/charenter_02.wav',
    'Terminal 3/enter/charenter_03.wav'
  ];
  const src=files[Math.floor(Math.random()*files.length)];
  const audio=new Audio(src);
  audio.volume=selectVolume;
  audio.play();
}

function playPasswordResult(correct){
  const file=correct?'Terminal 3/passgood.wav':'Terminal 3/passbad.wav';
  const audio=new Audio(file);
  audio.volume=selectVolume;
  audio.play();
}

function sleep(ms){return new Promise(r=>setTimeout(r,ms));}

async function typeText(el,text){
  for(let ch of text){
    el.textContent+=ch;
    const delay=speed===Infinity?0:baseDelay/speed;
    if(delay>0) await sleep(delay);
  }
  el.textContent+='\n';
  if(el.parentElement===historyEl){
    historyEl.scrollTop=historyEl.scrollHeight;
  }
}

function splitEntities(str){
  const div=document.createElement('div');
  div.textContent=str;
  const encoded=div.innerHTML;
  return encoded.match(/&[a-zA-Z0-9#]+;|./g)||[];
}

function decodeEntity(entity){
  const div=document.createElement('div');
  div.innerHTML=entity;
  return div.textContent;
}

async function typeHtml(el,html){
  const template=document.createElement('template');
  template.innerHTML=html;

  async function typeNode(target,node){
    for(const child of node.childNodes){
      if(child.nodeType===Node.TEXT_NODE){
        await typeTextNode(target,child.textContent);
      }else if(child.nodeType===Node.ELEMENT_NODE){
        const clone=child.cloneNode(false);
        target.appendChild(clone);
        await typeNode(clone,child);
      }
    }
  }

  async function typeTextNode(target,text){
    const units=splitEntities(text);
    const textNode=document.createTextNode('');
    target.appendChild(textNode);
    for(const unit of units){
      textNode.data+=unit.startsWith('&')?decodeEntity(unit):unit;
      const delay=speed===Infinity?0:baseDelay/speed;
      if(delay>0) await sleep(delay);
    }
  }

  await typeNode(el,template.content);
}
function waitForContinue(){
  return new Promise(res=>{
    function handler(e){
      if(e.type==='mousedown'&&e.button===0){cleanup();}
    }
    function cleanup(){
      document.removeEventListener('mousedown',handler);
      res();
    }
    document.addEventListener('mousedown',handler);
  });
}

document.addEventListener('mousedown',e=>{
  if(!typing) return;
  if(e.button===0){
    speed=Infinity;
    skipNextClick=true;
    e.preventDefault();
  }
});
document.addEventListener('click',e=>{
  if(skipNextClick){
    e.preventDefault();
    e.stopPropagation();
    skipNextClick=false;
  }
},true);

async function init(){
  startScrollSound();
  header.innerHTML='';
  stopScrollSound();
  if(startLocked){
    await startHacking();
  }else{
    await showIntro();
  }
}

async function showIntro(){
  restoreInput();
  startScrollSound();
  header.innerHTML='';
  content.innerHTML='';
  header.classList.remove('hack-header');
  content.classList.remove('hack-content');
  header.style.marginLeft='-2ch';
  header.style.textAlign='left';
  for(const line of titleLines){
    const div=document.createElement('div');
    div.style.textAlign='center';
    header.appendChild(div);
    await typeText(div,line);
  }
  for(const line of headerLines){
    const div=document.createElement('div');
    div.style.marginLeft='2ch';
    header.appendChild(div);
    await typeText(div,line);
  }
  stopScrollSound();
  showScreen('menu');
}

async function showScreen(name){
  restoreInput();
  clearResponses();
  screenHistory.push(name);
  inputText='';
  input.textContent='';
  updateInput();
  content.innerHTML='';
  currentOptions=[];
  selected=-1;
  const lines=screens[name];
  let i=0;
  while(i<lines.length){
    speed=1;
    typing=true;
    startScrollSound();
    while(i<lines.length){
      const line=lines[i];
      const div=document.createElement('div');
      content.appendChild(div);
      if(typeof line==='object'){
        div.className='option';
        div.tabIndex=0;
        await typeText(div,line.text);
        div.addEventListener('click',()=>{
          playSelectSound();
          if(line.screen){
            showScreen(line.screen);
          }else if(line.command){
            displayMessage(line.command);
          }
        });
        div.addEventListener('mouseenter',()=>{
          if(selected>=0){
            currentOptions[selected].classList.remove('selected');
            selected=-1;
          }
          playFocusSound();
        });
        currentOptions.push(div);
      }else{
        await typeText(div,line);
      }
      if(content.scrollHeight>content.clientHeight){
        content.removeChild(div);
        if(typeof line==='object') currentOptions.pop();
        typing=false;
        stopScrollSound();
        await waitForContinue();
        content.innerHTML='';
        currentOptions=[];
        selected=-1;
        break;
      }else{
        i++;
      }
    }
    if(typing){
      typing=false;
      stopScrollSound();
      if(i<lines.length){
        await waitForContinue();
        content.innerHTML='';
        currentOptions=[];
        selected=-1;
      }
    }
  }
}

document.addEventListener('keydown',e=>{
  if(typing || !currentOptions.length) return;
  if(e.key==='ArrowDown'){
    if(selected>=0) currentOptions[selected].classList.remove('selected');
    selected=selected<0?0:(selected+1)%currentOptions.length;
    currentOptions[selected].classList.add('selected');
    currentOptions[selected].focus();
    playFocusSound();
  }else if(e.key==='ArrowUp'){
    if(selected>=0) currentOptions[selected].classList.remove('selected');
    selected=selected<0?currentOptions.length-1:(selected-1+currentOptions.length)%currentOptions.length;
    currentOptions[selected].classList.add('selected');
    currentOptions[selected].focus();
    playFocusSound();
  }else if(e.key==='Enter' && selected>=0){
    currentOptions[selected].click();
  }
});

document.addEventListener('keydown',e=>{
  if(e.key==='Tab'){
    e.preventDefault();
    if(!typing) goBack();
  }
});

powerButton.addEventListener('click',async()=>{
  await audioCtx.resume();
  if(!powered){
    const powerSound=new Audio('Terminal 3/poweron.mp3');
    powerSound.play();
    powerScreen.style.display='none';
    terminal.classList.add('powered');
    audioMenu.style.display='flex';
    startFanHum();
    if(!terminalLocked){
      header.innerHTML='';
      content.innerHTML='';
      screenHistory=[];
      currentOptions=[];
      selected=-1;
      inputText='';
      input.textContent='';
      updateInput();
      hackingActive=false;
      hackingData=null;
      await loadConfig();
      loadScrollSound().then(init);
    }
    powered=true;
  }else{
    const powerSound=new Audio('Terminal 3/poweroff.mp3');
    powerSound.play();
    stopFanHum();
    stopScrollSound();
    powerScreen.style.display='flex';
    terminal.classList.remove('powered');
    audioMenu.style.display='none';
    volumeControls.style.display='none';
    hackingActive=false;
    hackingData=null;
    powered=false;
  }
});
</script>
</body>
</html>
